# 31. Next Permutation

链接: https://leetcode.com/problems/next-permutation/

题目：

Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be **in-place** and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`



## 解析

给定一个排列，调整排列的顺序使得新排列为下一个大于原排列的排列。如果本身排列已经是最大的了，则直接逆序原排列。

为了能找到一个刚好比原序列大的数，可以分析得：

* 我们希望调整的位置越往后越好
  * 例如 `123456`，相比于`123546` 或其他情况， `123465`当然是我们所求的
* 对于已经是从大到小的序列我们是无法做调整了，因为无法找到比他更大的序列
  * 例如 一个序列中的一部分为 `....9642`，我们无法对`9642`进行调整

* 比如交换的位置是i和j(i>j)，要使得交换后的序列比原序列大，需要满足nums[i]<nums[j]

根据这几点，我们可以得到算法：

1. 从后往前遍历，若是nums[i]>nums[i+1] (前一个小于后一个)，则找到了可进行调整的位置i
2. [i+1,n)中，从后往前遍历，若遇到比nums[i]大的数nums[j]，直接和nums[i]交换
3. 逆序[i+1,n)之间的数

每一步我们都给出一个解释：

1. 从后往前遍历是为了找到一个尽量靠后的交换位置，如果遍历过程中nums[i]<nums[i+1] (前一个大于后一个)，我们是无法对其进行调整的，只能继续遍历。
2. [i+1,n)一定是有序的，遍历过程中遇到第一个比nums[i]大的一定是刚好比nums[i]大的数。
3. 相比于原序列，第i个位置上新序列是大于原序列的，所以新序列是大于原序列的，逆序[1+1,n)是为了是他们更接近。 

```Python
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        for i in range(1, len(nums)):
            if nums[-i]>nums[-(i+1)]:
                for j in range(1, i+1):
                    if nums[-j]>nums[-(i+1)]:
                        nums[-j], nums[-(i+1)] = nums[-(i+1)], nums[-j]
                        break
                left, right = i, 1
                while left>right:
                    nums[-left], nums[-right] = nums[-right], nums[-left]
                    left, right = left-1, right+1
                break
        else:
            nums.reverse()
```

