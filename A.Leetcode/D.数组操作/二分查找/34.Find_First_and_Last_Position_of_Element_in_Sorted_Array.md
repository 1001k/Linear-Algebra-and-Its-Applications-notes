# 34. Find First and Last Position of Element in Sorted Array

链接： https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

题目：

Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

If the target is not found in the array, return `[-1, -1]`.

**Example 1:**

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

**Example 2:**

```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```



## 解析

要求在O(logn)的时间复杂度内，从有序数组nums中找出值为target的下标范围。

查找问题一般都采用二分查找，要找出值为target的下标范围，因此需要知道target出现的第一个坐标以及最后一个坐标，这就很考验编写二分查找的功底。

具体可以参考[binary_search的经典写法](./binary_search的经典写法)，只需要计算两次二分查找即可，一次找上界一次找下界，代码如下

```Python
class Solution(object):
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        def binary_search_lowest(nums, target):
            low, high = 0, len(nums)
            while low<high:
                mid = low + (high-low)//2
                if target<=nums[mid]:
                    high = mid
                else:
                    low = mid+1
            return low
        
        def binary_search_highest(nums, target):
            low, high = 0, len(nums)
            while low<high:
                mid = low + (high-low)//2
                if target<nums[mid]:
                    high = mid
                else:
                    low = mid+1
            return low
        
        if len(nums) == 0:
            return [-1, -1]
        lowest = binary_search_lowest(nums, target)
        highest = binary_search_highest(nums, target)
        if lowest>=len(nums) or nums[lowest] != target:
            return [-1, -1]
        
        return [lowest, highest-1]
```